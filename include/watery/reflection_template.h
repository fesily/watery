#pragma	once
#include <boost/preprocessor.hpp>
#include <watery/watery.hpp>

#define WATERY_TYPENAME 1

#define WATERY_MAKE_TEMPLATE_TYPENAME_II(n) (typename BOOST_PP_CAT(T,n))
#define WATERY_MAKE_TEMPLATE_TYPENAME_I(n,t) BOOST_PP_IF(BOOST_PP_IS_1(t),WATERY_MAKE_TEMPLATE_TYPENAME_II(n),BOOST_PP_EMPTY())
#define WATERY_MAKE_TEMPLATE_TYPENAME(n,data,t) WATERY_MAKE_TEMPLATE_TYPENAME_I(n,t)

#define WATERY_MAKE_TEMPLATE_TYPE_II(n) (BOOST_PP_CAT(T,n))
#define WATERY_MAKE_TEMPLATE_TYPE_I(n,t) BOOST_PP_IF(BOOST_PP_IS_1(t),WATERY_MAKE_TEMPLATE_TYPE_II(n),(t))
#define WATERY_MAKE_TEMPLATE_TYPE(n,data,t) WATERY_MAKE_TEMPLATE_TYPE_I(n,t)

#define WATERY_SEQ_TO_TUPLE(seq) BOOST_PP_IIF(BOOST_PP_IS_EMPTY(seq),(),seq)
#define WATERY_MACRO_EXPAND_EAT(...)
#define WATERY_SEQ_ENUM(seq) BOOST_PP_IIF(BOOST_PP_IS_EMPTY(WATERY_MACRO_EXPAND seq ),WATERY_MACRO_EXPAND_EAT,BOOST_PP_SEQ_ENUM)(seq)

#define WATERY_REFLEX_NAMESPACE_TEMPLATE_BEGIN_1(NAME,TYPE,DATA) \
			namespace reflect_details{									\
				template<typename...args> struct NAME##_iguana_reflect_members; \
				template<WATERY_SEQ_ENUM(DATA)>\
				struct NAME##_iguana_reflect_members<WATERY_REFLEX_NAMESPACE_TEMPLATE_EXPAND_TYPE(TYPE)>

#define WATERY_REFLEX_NAMESPACE_TEMPLATE_END_1 }
#define WATERY_REFLEX_NAMESPACE_TEMPLATE_1(NAME,TYPE,DATA)\
		template<WATERY_SEQ_ENUM(DATA)>\
		reflect_details::NAME##_iguana_reflect_members<WATERY_REFLEX_NAMESPACE_TEMPLATE_EXPAND_TYPE(TYPE)>

#define WATERY_REFLEX_NAMESPACE_TEMPLATE_BEGIN_0(NAME,TYPE,DATA) struct __reflecx__
#define WATERY_REFLEX_NAMESPACE_TEMPLATE_END_0
#define WATERY_REFLEX_NAMESPACE_TEMPLATE_0(NAME,TYPE,DATA) friend __reflecx__
#define WATERY_REFLEX_NAMESPACE_TEMPLATE_BEGIN(n,NAME,TYPE,DATA) WATERY_CAT(WATERY_REFLEX_NAMESPACE_TEMPLATE_BEGIN_,n)(NAME,TYPE,DATA)
#define WATERY_REFLEX_NAMESPACE_TEMPLATE_END(n) WATERY_CAT(WATERY_REFLEX_NAMESPACE_TEMPLATE_END_,n)
#define WATERY_REFLEX_NAMESPACE_TEMPLATE_EXPAND_TYPE(Type) WATERY_MACRO_EXPAND Type
#define WATERY_REFLEX_NAMESPACE_TEMPLATE_(n,NAME,TYPE,DATA) WATERY_CAT(WATERY_REFLEX_NAMESPACE_TEMPLATE_,n)(NAME,TYPE,DATA)

#define WATERY_MAKE_TEMPLATE_TYPE_NAME(NAME,TYPE)  (NAME##<BOOST_PP_TUPLE_ENUM(BOOST_PP_SEQ_TO_TUPLE(TYPE))>)

#define WATERY_TEMPLATE_REFLECTION(NAME,BASE_TYPE,TEYPNAMES,N,...)\
			WATERY_META_DATA(WATERY_REFLEX_NAMESPACE_TEMPLATE_,1,\
			WATERY_SEQ_TO_TUPLE(BOOST_PP_SEQ_FOR_EACH(WATERY_MAKE_TEMPLATE_TYPENAME,~,TEYPNAMES)),NAME, \
			WATERY_MAKE_TEMPLATE_TYPE_NAME(NAME,BOOST_PP_SEQ_FOR_EACH(WATERY_MAKE_TEMPLATE_TYPE,~,TEYPNAMES)),BASE_TYPE, \
			WATERY_CAT(WATERY_MAKE_ARG_LIST_WTO_OPERATOR_,N)(WATERY_REFLEX_NAME_OVERLOAD, WATERY_REFLEX_NAME_NORMAL_INFO, __VA_ARGS__),\
			WATERY_CAT(WATERY_MAKE_ARG_LIST_WTO_OPERATOR_,N)(WATERY_REFLEX_META_OVERLOAD, WATERY_REFLEX_META_NORMAL_INFO, __VA_ARGS__))

#define WATERY_MAKE_TYPENAME_LIST(r,n,data) WATERY_TYPENAME
/**
* \brief reflection template object
* \param STRUCT_NAME name
* \param TYPENAME_N number of typename
*/
#define WATERY_REFLECTION_TEMPLATE(STRUCT_NAME,								\
							TYPENAME_N, ...)								\
			WATERY_TEMPLATE_REFLECTION(STRUCT_NAME,WATERY_EMPTY_BASE_TYPE(),\
			BOOST_PP_TUPLE_TO_SEQ((BOOST_PP_ENUM(TYPENAME_N,WATERY_MAKE_TYPENAME_LIST,~))),			\
								WATERY_GET_ARG_COUNT(__VA_ARGS__), __VA_ARGS__)

/*
* example:
*  template<typename T1,typename T2> Test{T1 a; void b(T2){}};
*  WATERY_REFLECTION_TEMPLATE_PARTIAL(Test,(int,WATERY_TYPENAME),(a,b))
*/
/**
* \brief reflection partial template object
* \param STRUCT_NAME name
* \param STRUCT_TYPENAME partial typename 
*			(example1: (WATERY_TYPENAME,int,WATERY_TYPENAME,double) )
*			(example2: WATERY_FLAG_FULL_PARATIAL )
* \param TYPENAME_N number of typename
*/
#define WATERY_REFLECTION_TEMPLATE_PARTIAL(STRUCT_NAME, STRUCT_TYPENAME, ...) \
	WATERY_TEMPLATE_REFLECTION(STRUCT_NAME,	WATERY_EMPTY_BASE_TYPE(), \
							   BOOST_PP_TUPLE_TO_SEQ(STRUCT_TYPENAME), \
							   WATERY_GET_ARG_COUNT(__VA_ARGS__),__VA_ARGS__)

